{% extends "base.html" %}

{% block app_content %}
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
    <link rel="stylesheet" href="../static/main1119.css"/>
    <script src="../static/es5.min.js"></script>
    <script src="../static/maps.js"></script>
    <!-- UI组件库 1.0 -->
    <script src="../static/main.js"></script>
    <script src="../static/plotly-latest.min.js"></script>
</head>
<style type="text/css">
    .inputNum {
      width: 4em;
      text-align: right;
    }
    #viewDiv {
      height: 600px;
    }
    #info {
      background-color:whitesmoke;
      z-index: 100;
      position: absolute; 
      bottom: 0;
      right: 0;
    }
    .PRDiv{
      position: relative;
      float:right;
      width:900px;
      z-index: 100;
    }
    .lineDiv{
      position: relative;
      float:right;
      width:290px;
      margin-left:-50px;
      z-index: 10;
    }
    .saveLine{
      z-index: 100;
      position: absolute;
      right: 60px;
      top: 42px;
      border-radius: 3px;
      background-color: rgb(255, 255, 255);
    }
    .savePic{
      z-index: 100;
      position: absolute;
      right: 10px;
      top: 42px;
      border-radius: 3px;
      background-color: rgb(255, 255, 255);
    }
    .close-btn {
        position: absolute;
        top: -6px;
        right: -8px;
        width: 15px;
        height: 15px;
        font-size: 12px;
        background: #ccc;
        border-radius: 50%;
        color: #fff;
        text-align: center;
        line-height: 15px;
        box-shadow: -1px 1px 1px rgba(10, 10, 10, .2);
    }
</style>
<select  id="channel">
    <option>平行通道距离校正信号</option>
    <option>垂直通道距离校正信号</option>
    <option>消光系数</option>
    <option>退偏比</option>
    <option>污染边界层</option>
    <option>平行通道原始信号</option>
    <option>垂直通道原始信号</option>
</select>
<span>
    &nbsp;&nbsp;&nbsp;&nbsp;从<input type="number" id="zMin" value="0" class="inputNum" max="30000" min="15">
    至<input type="number" id="zMax" value="3000" class="inputNum" max="30000" min="15">&nbsp;&nbsp;&nbsp;&nbsp;
</span>
<span>
    色标最小值<input type="number" id="colorMin" value="0" class="inputNum">
    色标最大值<input type="number" id="colorMax" value="10000" class="inputNum">
    &nbsp;&nbsp;&nbsp;&nbsp;
    透明度<input type="number" id="opacity" value="0.5" class="inputNum">
    比例×<input type="number" id="scale" value="1" class="inputNum">
</span>
  
<div id="viewDiv">
  <!-- <div class="input-card" id = "info">  
    <div>游标当前位置：</div>
    <div class="input-item">
      <span id="lnglat"></span>
    </div>
    <div class="input-item">
      <span id="address"></span>
    </div>
  </div> -->
</div>
<div>
  <div class = 'lineDiv' id='lineADiv'>  
      <input class="saveLine" type="image" title="保存廓线" src="../static/save.png" onclick="SaveLineA()"/>
  </div>
  <div class = 'PRDiv' id="PRADiv"><!-- Plotly chart will be drawn inside this DIV -->
    <input class="savePic" type="image" title="保存图片" src="../static/save.png" onclick="SaveHeatA()"/>
  </div>
</div>

{% endblock %}

{% block app_scripts %}

<script type="text/javascript">
  var task_id = '{{task_id}}';
  var map = new AMap.Map('viewDiv', {
        viewMode:'3D',  
        expandZoomRange:true,
        zooms:[3,20],
        zoom:14,
        pitch:60,
        center:[116.396132,39.900444]
    });

    var object3Dlayer = new AMap.Object3DLayer();
    map.add(object3Dlayer);

    AMapUI.loadUI(['control/BasicControl'], function(BasicControl) {
      var layerCtrl = new BasicControl.LayerSwitcher({
          position: 'rt',
          
           //自定义基础图层
            baseLayers: [{
                enable: true,
                id: 'Gtile',
                name: '谷歌矢量图',
                layer: new AMap.TileLayer({
                  getTileUrl: 'http://mt{1,2,3,0}.google.cn/vt/lyrs=m@126&hl=zh-CN&gl=cn&src=app&s=G&x=[x]&y=[y]&z=[z]',
                  zIndex:2
                })
            },{
                id: 'Gsatellite',
                name: '谷歌卫星图',
                layer: new AMap.TileLayer({
                  getTileUrl: 'http://mt{1,2,3,0}.google.cn/vt/lyrs=y@126&hl=zh-CN&gl=cn&src=app&s=G&x=[x]&y=[y]&z=[z]',
                  zIndex:2
                })
            },{
                id: 'Atile',
                name: '高德矢量图',
                layer: new AMap.TileLayer()
            }, {
                id: 'Asatellite',
                name: '高德卫星图',
                layer: new AMap.TileLayer.Satellite()
             }],
            //自定义覆盖图层
            overlayLayers: [ {
                id: 'roadNet',
                name: '高德路网图',
                layer: new AMap.TileLayer.RoadNet()
            },{
                enable: true,
                id: 'object3D',
                name: '雷达扫描图',
                layer: object3Dlayer
            }]
      });
      //图层切换控件
      map.addControl(layerCtrl);
      map.setLayers(layerCtrl.getEnabledLayers());
    });

    AMap.plugin([
        'AMap.ControlBar',
        'AMap.Scale'
    ], function(){

        // 添加 3D 罗盘控制
        map.addControl(new AMap.ControlBar({
            position: {left:'-90px'} 
        }));
        map.addControl(new AMap.Scale());
    });

    function createRectangle(pt1, pt2, resl, zMin, zMax, zScale, idata, rdata, vmin, vmax, alpha) {
        var v1xy = map.lngLatToGeodeticCoord(pt1);
        var v2xy = map.lngLatToGeodeticCoord(pt2);
        var v1z = 0;
        var v2z = 0;
        var x1 = [], y1 = [],z1 = [], x2 = [], y2 = [], z2 = [];
        var nmax = Math.floor(zMax/resl);
        var nmin = Math.floor(zMin/resl);
        resl *= zScale;
        for(var i = nmin; i<nmax+1; i++){
          x1.push(v1xy.x);
          y1.push(v1xy.y);
          z1.push(v1z-i*resl);
          x2.push(v2xy.x);
          y2.push(v2xy.y);
          z2.push(v2z-i*resl);
        }

        var rectangle = new AMap.Object3D.Mesh()
        rectangle.transparent = true;
        rectangle.backOrFront = 'both';

        var geometry = rectangle.geometry;
        for(var i = 0; i<nmax-nmin; i++){
          geometry.vertices.push(x1[i], y1[i], z1[i]);
          geometry.vertices.push(x1[i+1], y1[i+1], z1[i+1]);
          geometry.vertices.push(x2[i+1], y2[i+1], z2[i+1]);
          geometry.vertices.push(x1[i], y1[i], z1[i]);
          geometry.vertices.push(x2[i], y2[i], z2[i]);
          geometry.vertices.push(x2[i+1], y2[i+1], z2[i+1]);
          var xc1 = getColor(rdata[idata][i+nmin], vmin, vmax, alpha);
          var xc2 = getColor(rdata[idata][i+1+nmin], vmin, vmax, alpha);
          var xc3 = getColor(rdata[idata+1][i+nmin], vmin, vmax, alpha);
          var xc4 = getColor(rdata[idata+1][i+1+nmin], vmin, vmax, alpha);
          geometry.vertexColors.push(xc1.r, xc1.g, xc1.b, xc1.a);
          geometry.vertexColors.push(xc2.r, xc2.g, xc2.b, xc2.a);
          geometry.vertexColors.push(xc4.r, xc4.g, xc4.b, xc4.a);
          geometry.vertexColors.push(xc1.r, xc1.g, xc1.b, xc1.a);
          geometry.vertexColors.push(xc3.r, xc3.g, xc3.b, xc3.a);
          geometry.vertexColors.push(xc4.r, xc4.g, xc4.b, xc4.a);
        }
          
        return rectangle;
    }

    function createWall(pts,rdata,resl,zMin,zMax,zScale,vmin,vmax,opacity) {
        var n =  pts.length - 1;
        var v0xy = map.lngLatToGeodeticCoord(pts[0]);
        var v1xy = map.lngLatToGeodeticCoord(pts[0].offset(5000,0));
        scal = (v1xy.x-v0xy.x)/5000;
        resl *= scal;
        zMax *= scal;
        zMin *= scal;
        for(let i=0;i<n;i++){
            var rect = createRectangle(pts[i],pts[i+1],resl,zMin,zMax,zScale,i,rdata,vmin,vmax,opacity);
            object3Dlayer.add(rect);
        }         
    }

    function getColor(v, vmin, vmax, alpha){
        var c = {};
        if (v < vmin){
          v = vmin;
        }          
        if (v > vmax){
          v = vmax;
        }
        var dv = vmax - vmin;
        c.a = alpha-0.1+0.2*(v - vmin) / dv;

        if (v < (vmin + 0.25 * dv)) {
            var g = 4 * (v - vmin) / dv;
            c.r = 0;
            c.g = g;
            c.b = 1;
        } else if (v < (vmin + 0.5 * dv)) {
            var b = 1 + 4 * (vmin + 0.25 * dv - v) / dv;
            c.r = 0;
            c.g = 1;
            c.b = b;
        } else if (v < (vmin + 0.75 * dv)) {
            var r = 4 * (v - vmin - 0.5 * dv) / dv;
            c.r = r;
            c.g = 1;
            c.b = 0;
        } else {
            var g = 1 + 4 * (vmin + 0.75 * dv - v) / dv;
            c.r = 1;
            c.g = g;
            c.b = 0;
        }
        return c;
    }

    function createColorScale(n){
      var colorScale = [];
      for(let i=0;i<n;i++){
        var c = getColor(i/(n-1),0,1,1);
        var rgbStr = 'rgb('+Math.floor(c.r*255)+','+Math.floor(c.g*255)+','+Math.floor(c.b*255)+')';
        colorScale.push([i/(n-1),rgbStr]);
      }
      return colorScale;
    }

    var rdata = {};
    var rangeMax = 3000;
    var rangeMin = 0;
    var vMax = 10000;
    var vMin = 0;
    var colorOpacity = 0.5;
    var rangeScale = 1;
    var scal = 1;
    var resolution = 15;
    var locations = [];
    var drawData = [];
    var timeat=[];
    var height = [];
    var lines, points3D;
    var drawName = '平行通道距离校正信号';
    var poistionLabel;
    var layoutA = {
          xaxis: {
            title: '时间',
            showline: true,
            tickmode:'auto',
            range:[],
            showspikes: true,
            spikemode: 'across'
          },
          yaxis: {
            title: '距离(km)',
            showline: true,
            range:[0,3]
          }
        };
    var layoutLineA = {
          xaxis: {
            title: '强度',
            showline: true,
            tickmode:'auto',
            showexponent:"last",
            exponentformat:"power"
          },
          yaxis: {
            showline: true,
            range:[0,3],
            ticks:'outside'
          },
          annotations: [{
          showarrow: false,
          text: "",
          font: {
            color: 'black'
          },
          xref: 'paper',
          yref: 'paper',
          x: 0.5,
          y: 0.5
        }]
      };
    var layoutConfig = {
      displayModeBar: false,
      responsive: true
    };
    var PRA_data ={},traceA={},tracePbl={};
    $.post('{{ url_for('main.get_mov_data') }}', { 'task id': task_id},
          function(data,status){
            var channel = document.getElementById('channel');
            channel.addEventListener("change", SelectChannel);
            var colorMax = document.getElementById('colorMax');
            colorMax.addEventListener("change", ChangeMaxValue);
            var colorMin = document.getElementById('colorMin');
            colorMin.addEventListener("change", ChangeMinValue);
            var zMax = document.getElementById('zMax');
            zMax.addEventListener("change", ChangeRangeMax);
            var zMin = document.getElementById('zMin');
            zMin.addEventListener("change", ChangeRangeMin);
            var opacity = document.getElementById('opacity');
            opacity.addEventListener("change", ChangeColorOpacity);
            var scale = document.getElementById('scale');
            scale.addEventListener("change", ChangeRangeScale);

            rdata.raw_A = [];
            rdata.raw_B = [];
            rdata.prr_A = [];
            rdata.prr_B = [];
            rdata.ext = [];
            rdata.dep = [];
            rdata.pbl = [];
            resolution = data.result[0].resolution;
            var leng = data.result[0].raw_A.length;        
            for(let i = 0;i<leng;i++){
                height.push((i+1)*resolution/1000);
            };
            for(let i=0; i<data.result.length;i++){
                if(data.result[i].longitude>-180){
                    timeat.push(data.result[i].timestamp);
                    rdata.prr_A.push(data.result[i].prr_A);
                    rdata.prr_B.push(data.result[i].prr_B);
                    rdata.raw_A.push(data.result[i].raw_A);
                    rdata.raw_B.push(data.result[i].raw_B);
                    rdata.ext.push(data.result[i].ext);
                    rdata.dep.push(data.result[i].dep);
                    rdata.pbl.push(data.result[i].pbl/1000);
                    var longitude = data.result[i].longitude;
                    var latitude = data.result[i].latitude;
                    var altitude = data.result[i].altitude;
                    locations.push(Gps84ToGcj02(longitude,latitude));
                }             
            };
            drawData = rdata.prr_A;
            createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);
            map.setCenter(locations[0]);
            map.setFitView();
            createWallIndicator();

            PRA_data = {
              z: drawData,
              x: timeat,
              y: height,
              zmin: 0,
              zmax: 10000,
              type: 'heatmap',
              transpose: true,
              colorscale:createColorScale(11),
              colorbar:{
                thickness:15,
                xpad:5,
                showexponent:"last",
                exponentformat:"power"
              }
            };

            traceA = {
              x: drawData[0].slice(layoutLineA.yaxis.range[0]/resolution*1000,layoutLineA.yaxis.range[1]/resolution*1000),
              y: height,
              mode: 'lines',
              line: {
                color: 'black',
                width: 2
              }
            };

            tracePbl = {
              x:timeat,
              y:rdata.pbl,
              mode:'markers',
              type:'scatter',
              marker:{color:'black'},
              showlegend:false,
              visible:false
            };

            layoutA.xaxis.range = [timeat[0],timeat[timeat.length-1]];
            layoutLineA.annotations[0].text = timeat[lineIndex];
            Plotly.newPlot('PRADiv', [PRA_data,tracePbl], layoutA,layoutConfig);
            Plotly.newPlot('lineADiv',[traceA],layoutLineA,layoutConfig);

            plotA.on('plotly_hover',plotHover);

            poistionLabel = new AMap.Text({
                                  position:locations[lineIndex],
                                  height:rangeMax*scal*rangeScale,
                                  map:map
                                }) 

            setPositionLabel();
        });

    function createWallIndicator(){
      var center = map.lngLatToGeodeticCoord(locations[lineIndex]);
      lines = new AMap.Object3D.Line();
      var lineGeo = lines.geometry;
      points3D = new AMap.Object3D.RoundPoints();
      points3D.transparent = true;
      var pointsGeo = points3D.geometry;
      var height = scal*rangeMax*rangeScale;
      // 连线
      lineGeo.vertices.push(center.x, center.y, 0);
      lineGeo.vertexColors.push(0, 1, 1, 1);
      lineGeo.vertices.push(center.x, center.y, -height);
      lineGeo.vertexColors.push(0, 1, 1, 1);

      pointsGeo.vertices.push(center.x, center.y, 0); // 尾部小点
      pointsGeo.pointSizes.push(8);
      pointsGeo.vertexColors.push(0, 0, 1, 1);

      pointsGeo.vertices.push(center.x, center.y, -height); // 空中点
      pointsGeo.pointSizes.push(20);
      pointsGeo.vertexColors.push(2 * 0.029, 2 * 0.015, 2 * 0.01, 1);

      points3D.borderColor = [0.4, 0.8, 1, 1];
      points3D.borderWeight = 3;
      object3Dlayer.add(lines);
      object3Dlayer.add(points3D);
    }

    map.on('mousemove', function (ev) {
      var pixel = ev.pixel;
      var px = new AMap.Pixel(pixel.x, pixel.y);
      var obj = map.getObject3DByContainerPos(px, [object3Dlayer], false) || {};

      points3D.geometry.vertexColors.splice(4,4,2 * 0.029, 2 * 0.015, 2 * 0.01, 1);
      if(obj.object==points3D){
        points3D.geometry.vertexColors.splice(4,4,0, 1, 0, 1);
      }
      points3D.needUpdate = true;
      points3D.reDraw();
    });

    map.on('click', function (ev) {
      var pixel = ev.pixel;
      var px = new AMap.Pixel(pixel.x, pixel.y);
      var obj = map.getObject3DByContainerPos(px, [object3Dlayer], false) || {};

      if(obj.object==points3D){
        poistionLabel.show();
      }
    });

    var lineIndex = 0;
    var plotA = document.getElementById('PRADiv');
    var geocoder;
    function plotHover(data){
      var pn='';
      for(let i=0;i<data.points.length;i++){
        if(data.points[i].fullData.type==='heatmap'){
          pn = data.points[i].pointNumber;
        }
      }
      lineIndex = pn[1];
      var center = map.lngLatToGeodeticCoord(locations[lineIndex]);
      var z = scal*rangeMax*rangeScale;

      lines.geometry.vertices.splice(0,6,center.x, center.y, 0,center.x, center.y, -z);
      lines.needUpdate = true;

      points3D.geometry.vertices.splice(0,6,center.x, center.y, 0,center.x, center.y, -z);
      points3D.needUpdate = true;
      lines.reDraw();
      points3D.reDraw();

      setPositionLabel();

      traceA.x = drawData[lineIndex].slice(layoutLineA.yaxis.range[0]/resolution*1000,layoutLineA.yaxis.range[1]/resolution*1000);
      traceA.y = height.slice(layoutLineA.yaxis.range[0]/resolution*1000,layoutLineA.yaxis.range[1]/resolution*1000);


      layoutLineA.annotations[0].text = timeat[lineIndex];
      Plotly.react('lineADiv',[traceA],layoutLineA);
    }

    function setPositionLabel(){
      var distance = (AMap.GeometryUtil.distanceOfLine(locations.slice(0,lineIndex))/1000).toFixed(1);

      // document.getElementById("lnglat").textContent = locations[lineIndex].lng + ',' + locations[lineIndex].lat;
      if(!geocoder){
          geocoder = new AMap.Geocoder({
              city: "010", //城市设为北京，默认：“全国”
              radius: 1000 //范围，默认：500
          });
      } 
      geocoder.getAddress(locations[lineIndex], function(status, result) {
          if (status === 'complete'&&result.regeocode) {
              var address = result.regeocode.formattedAddress;
              // document.getElementById('address').textContent = address;
              poistionLabel.setPosition(locations[lineIndex]);
              poistionLabel.setLabel({
                  offset: new AMap.Pixel(10, 0),  //设置文本标注偏移量
                  content: "<div><div>当前位置"+locations[lineIndex].lng + ',' + locations[lineIndex].lat+"</div>"+
                           "<div>距起点"+distance+"km</div>"+
                           "<div class='info'>"+address+"</div>"+
                           "<div class='close-btn' onclick='hideMarker()'>X</div></div>", //设置文本标注内容
                  direction: 'right' //设置文本标注方位
              });
          }else{
              log.error('根据经纬度查询地址失败')
          }
      });
    }

    function hideMarker(){
      poistionLabel.hide();
    }

    function Gps84ToGcj02(lon,lat){
      if (outOfChina(lon, lat)) {
            return new AMap.LngLat(lon, lat);
      }
      let a = 6378245.0;
      let ee = 0.00669342162296594323;
      let dLat = TransformLat(lon - 105.0, lat - 35.0);
      let dLon = TransformLon(lon - 105.0, lat - 35.0);
      let radLat = lat / 180.0 * Math.PI;
      let magic = Math.sin(radLat);
      magic = 1 - ee * magic * magic;
      let sqrtMagic = Math.sqrt(magic);
      dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * Math.PI);
      dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI);
      let mgLat = lat + dLat;
      let mgLon = lon + dLon;
      return new AMap.LngLat(mgLon, mgLat);
    }

    function outOfChina(lon, lat) {
        if (lon < 72.004 || lon > 137.8347)
            return true;
        if (lat < 0.8293 || lat > 55.8271)
            return true;
        return false;
    }

    function TransformLat(x,y){
      var ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
      ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
      ret += (20.0 * Math.sin(y * Math.PI) + 40.0 * Math.sin(y / 3.0 * Math.PI)) * 2.0 / 3.0;
      ret += (160.0 * Math.sin(y / 12.0 * Math.PI) + 320 * Math.sin(y * Math.PI / 30.0)) * 2.0 / 3.0;
      return ret;
    }

    function TransformLon(x,y){
      var ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
      ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
      ret += (20.0 * Math.sin(x * Math.PI) + 40.0 * Math.sin(x / 3.0 * Math.PI)) * 2.0 / 3.0;
      ret += (150.0 * Math.sin(x / 12.0 * Math.PI) + 300.0 * Math.sin(x / 30.0 * Math.PI)) * 2.0 / 3.0;
      return ret;
    }

    function SelectChannel(){
        var channel = document.getElementById('channel');
        drawName = channel.options[channel.selectedIndex].text;
        tracePbl.visible = false;
        switch(drawName){
          case '平行通道距离校正信号':
            drawData = rdata.prr_A;
            break;
          case '垂直通道距离校正信号':
            drawData = rdata.prr_B;
            break;
          case '消光系数':
            drawData = rdata.ext;
            break;
          case '退偏比':
            drawData = rdata.dep;
            break;
          case '平行通道原始信号':
            drawData = rdata.raw_A;
            break;
          case '垂直通道原始信号':
            drawData = rdata.raw_B;
            break;
          case '污染边界层':
            tracePbl.visible = true;
            break;
        };
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);
        createWallIndicator();

        PRA_data.z = drawData;
        traceA.x = drawData[lineIndex].slice(layoutLineA.yaxis.range[0]/resolution*1000,layoutLineA.yaxis.range[1]/resolution*1000);
        
        Plotly.react('PRADiv',[PRA_data,tracePbl],layoutA);
        Plotly.react('lineADiv',[traceA],layoutLineA);
      }

      function ChangeMaxValue(){
        var colorMax = document.getElementById('colorMax');
        vMax = Number(colorMax.value);
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);
        createWallIndicator();

        var update = {
          zmax:vMax
        };
        Plotly.restyle('PRADiv',update);
      }

      function ChangeMinValue(){
        var colorMin = document.getElementById('colorMin'); 
        vMin = Number(colorMin.value);  
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);
        createWallIndicator(); 

        var update = {
          zmin:vMin
        };
        Plotly.restyle('PRADiv',update); 

      }

      function ChangeRangeMax(){
        var zMax = document.getElementById('zMax'); 
        rangeMax = Number(zMax.value);  
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity); 
        createWallIndicator();
        poistionLabel.setHeight(rangeMax*scal*rangeScale);
        
        layoutA.yaxis.range[1] = rangeMax/1000;
        layoutLineA.yaxis.range[1] = rangeMax/1000;
        var update = {
          'yaxis.range[1]':rangeMax/1000
        };
        Plotly.relayout('PRADiv',update);
        traceA.x = drawData[lineIndex].slice(layoutLineA.yaxis.range[0]/resolution*1000,layoutLineA.yaxis.range[1]/resolution*1000);
        traceA.y = height.slice(layoutLineA.yaxis.range[0]/resolution*1000,layoutLineA.yaxis.range[1]/resolution*1000);
        Plotly.react('lineADiv',[traceA],layoutLineA);
      }

      function ChangeRangeMin(){
        var zMin = document.getElementById('zMin'); 
        rangeMin = Number(zMin.value);  
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity); 
        createWallIndicator();
        
        layoutA.yaxis.range[0] = rangeMin/1000;
        layoutLineA.yaxis.range[0] = rangeMin/1000;
        var update = {
          'yaxis.range[0]':rangeMin/1000
        };
        Plotly.relayout('PRADiv',update);
        traceA.x = drawData[lineIndex].slice(layoutLineA.yaxis.range[0]/resolution*1000,layoutLineA.yaxis.range[1]/resolution*1000);
        traceA.y = height.slice(layoutLineA.yaxis.range[0]/resolution*1000,layoutLineA.yaxis.range[1]/resolution*1000);
        Plotly.react('lineADiv',[traceA],layoutLineA);
      }

      function ChangeColorOpacity(){
        var opacity = document.getElementById('opacity'); 
        colorOpacity = Number(opacity.value);  
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);  
        createWallIndicator();
      }

      function ChangeRangeScale(){
        var scale = document.getElementById('scale'); 
        rangeScale = Number(scale.value);  
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);   
        createWallIndicator();
        poistionLabel.setHeight(rangeMax*scal*rangeScale);
      }

      function SaveHeatA(){
        Plotly.downloadImage('PRADiv', {format: 'png', width: 1000, height: 500, filename: drawName+'从'
                          +timeat[0]+'至'+timeat[timeat.length-1]});
      }

      function SaveLineA(){
        let csvContent = "";
        csvContent += 'Data Length,'+drawData[lineIndex].length+'\r\n';
          csvContent += 'Resolution,'+resolution+'\r\n';
          csvContent += drawData[lineIndex].join(',')+'\r\n';
          var blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
          if (navigator.msSaveBlob) { // IE 10+
              navigator.msSaveBlob(blob, drawNameA+timeat[lineIndex]+".csv");
          } else {
              var link = document.createElement("a");
              if (link.download !== undefined) { // feature detection
                  // Browsers that support HTML5 download attribute
                  var url = URL.createObjectURL(blob);
                  link.setAttribute("href", url);
                  link.setAttribute("download", drawName+timeat[lineIndex]+".csv");
                  link.style.visibility = 'hidden';
                  document.body.appendChild(link);
                  link.click();
                  document.body.removeChild(link);
              }
          }
      }

</script>



{% endblock %}