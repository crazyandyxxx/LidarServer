{% extends "base.html" %}

{% block app_content %}
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
    <link rel="stylesheet" href="../static/main1119.css"/>
    <script src="../static/es5.min.js"></script>
    <script src="../static/maps.js"></script>
    <!-- UI组件库 1.0 -->
    <script src="../static/main.js"></script>
    <script src="../static/plotly-latest.min.js"></script>
</head>
<style type="text/css">
    .inputNum {
      width: 4em;
      text-align: right;
    }
    #viewDiv {
      height: 600px;
    }
</style>
<select  id="channel">
    <option>平行通道距离校正信号</option>
    <option>垂直通道距离校正信号</option>
    <option>消光系数</option>
    <option>退偏比</option>
    <option>污染边界层</option>
    <option>平行通道原始信号</option>
    <option>垂直通道原始信号</option>
</select>
<span>
    &nbsp;&nbsp;&nbsp;&nbsp;从<input type="number" id="zMin" value="0" class="inputNum" max="30000" min="15">
    至<input type="number" id="zMax" value="3000" class="inputNum" max="30000" min="15">&nbsp;&nbsp;&nbsp;&nbsp;
</span>
<span>
    色标最小值<input type="number" id="colorMin" value="0" class="inputNum">
    色标最大值<input type="number" id="colorMax" value="10000" class="inputNum">
    &nbsp;&nbsp;&nbsp;&nbsp;
    透明度<input type="number" id="opacity" value="0.5" class="inputNum">
    比例×<input type="number" id="scale" value="1" class="inputNum">
</span>
  
<div id="viewDiv"></div>
<div id="PRADiv"></div>

{% endblock %}

{% block app_scripts %}

<script type="text/javascript">
  var task_id = '{{task_id}}';
  var map = new AMap.Map('viewDiv', {
        viewMode:'3D',  
        expandZoomRange:true,
        zooms:[3,20],
        zoom:14,
        pitch:60,
        center:[116.396132,39.900444]
    });

    var object3Dlayer = new AMap.Object3DLayer();
    map.add(object3Dlayer);

    AMapUI.loadUI(['control/BasicControl'], function(BasicControl) {
      var layerCtrl = new BasicControl.LayerSwitcher({
          position: 'rt',
          
           //自定义基础图层
            baseLayers: [{
                enable: true,
                id: 'Gtile',
                name: '谷歌矢量图',
                layer: new AMap.TileLayer({
                  getTileUrl: 'http://mt{1,2,3,0}.google.cn/vt/lyrs=m@126&hl=zh-CN&gl=cn&src=app&s=G&x=[x]&y=[y]&z=[z]',
                  zIndex:2
                })
            },{
                id: 'Gsatellite',
                name: '谷歌卫星图',
                layer: new AMap.TileLayer({
                  getTileUrl: 'http://mt{1,2,3,0}.google.cn/vt/lyrs=y@126&hl=zh-CN&gl=cn&src=app&s=G&x=[x]&y=[y]&z=[z]',
                  zIndex:2
                })
            },{
                id: 'Atile',
                name: '高德矢量图',
                layer: new AMap.TileLayer()
            }, {
                id: 'Asatellite',
                name: '高德卫星图',
                layer: new AMap.TileLayer.Satellite()
             }],
            //自定义覆盖图层
            overlayLayers: [ {
                id: 'roadNet',
                name: '高德路网图',
                layer: new AMap.TileLayer.RoadNet()
            },{
                enable: true,
                id: 'object3D',
                name: '雷达扫描图',
                layer: object3Dlayer
            }]
      });
      //图层切换控件
      map.addControl(layerCtrl);
      map.setLayers(layerCtrl.getEnabledLayers());
    });

    AMap.plugin([
        'AMap.ControlBar',
        'AMap.Scale'
    ], function(){

        // 添加 3D 罗盘控制
        map.addControl(new AMap.ControlBar({
            position: {left:'-90px'} 
        }));
        map.addControl(new AMap.Scale());
    });

    function createRectangle(pt1, pt2, resl, zMin, zMax, zScale, idata, rdata, vmin, vmax, alpha) {
        var v1xy = map.lngLatToGeodeticCoord(pt1);
        var v2xy = map.lngLatToGeodeticCoord(pt2);
        var v1z = 0;
        var v2z = 0;
        var x1 = [], y1 = [],z1 = [], x2 = [], y2 = [], z2 = [];
        var nmax = Math.floor(zMax/resl);
        var nmin = Math.floor(zMin/resl);
        resl *= zScale;
        for(var i = nmin; i<nmax+1; i++){
          x1.push(v1xy.x);
          y1.push(v1xy.y);
          z1.push(v1z-i*resl);
          x2.push(v2xy.x);
          y2.push(v2xy.y);
          z2.push(v2z-i*resl);
        }

        var rectangle = new AMap.Object3D.Mesh()
        rectangle.transparent = true;
        rectangle.backOrFront = 'both';

        var geometry = rectangle.geometry;
        for(var i = 0; i<nmax-nmin; i++){
          geometry.vertices.push(x1[i], y1[i], z1[i]);
          geometry.vertices.push(x1[i+1], y1[i+1], z1[i+1]);
          geometry.vertices.push(x2[i+1], y2[i+1], z2[i+1]);
          geometry.vertices.push(x1[i], y1[i], z1[i]);
          geometry.vertices.push(x2[i], y2[i], z2[i]);
          geometry.vertices.push(x2[i+1], y2[i+1], z2[i+1]);
          var xc1 = getColor(rdata[idata][i+nmin], vmin, vmax, alpha);
          var xc2 = getColor(rdata[idata][i+1+nmin], vmin, vmax, alpha);
          var xc3 = getColor(rdata[idata+1][i+nmin], vmin, vmax, alpha);
          var xc4 = getColor(rdata[idata+1][i+1+nmin], vmin, vmax, alpha);
          geometry.vertexColors.push(xc1.r, xc1.g, xc1.b, xc1.a);
          geometry.vertexColors.push(xc2.r, xc2.g, xc2.b, xc2.a);
          geometry.vertexColors.push(xc4.r, xc4.g, xc4.b, xc4.a);
          geometry.vertexColors.push(xc1.r, xc1.g, xc1.b, xc1.a);
          geometry.vertexColors.push(xc3.r, xc3.g, xc3.b, xc3.a);
          geometry.vertexColors.push(xc4.r, xc4.g, xc4.b, xc4.a);
        }
          
        return rectangle;
    }

    function createWall(pts,rdata,resl,zMin,zMax,zScale,vmin,vmax,opacity) {
        var n =  pts.length - 1;
        var v0xy = map.lngLatToGeodeticCoord(pts[0]);
        var v1xy = map.lngLatToGeodeticCoord(pts[0].offset(5000,0));
        scal = (v1xy.x-v0xy.x)/5000;
        resl *= scal;
        zMax *= scal;
        zMin *= scal;
        for(let i=0;i<n;i++){
            var rect = createRectangle(pts[i],pts[i+1],resl,zMin,zMax,zScale,i,rdata,vmin,vmax,opacity);
            object3Dlayer.add(rect);
        }         
    }

    function getColor(v, vmin, vmax, alpha){
        var c = {};
        if (v < vmin){
          v = vmin;
        }          
        if (v > vmax){
          v = vmax;
        }
        var dv = vmax - vmin;
        c.a = alpha-0.1+0.2*(v - vmin) / dv;

        if (v < (vmin + 0.25 * dv)) {
            var g = 4 * (v - vmin) / dv;
            c.r = 0;
            c.g = g;
            c.b = 1;
        } else if (v < (vmin + 0.5 * dv)) {
            var b = 1 + 4 * (vmin + 0.25 * dv - v) / dv;
            c.r = 0;
            c.g = 1;
            c.b = b;
        } else if (v < (vmin + 0.75 * dv)) {
            var r = 4 * (v - vmin - 0.5 * dv) / dv;
            c.r = r;
            c.g = 1;
            c.b = 0;
        } else {
            var g = 1 + 4 * (vmin + 0.75 * dv - v) / dv;
            c.r = 1;
            c.g = g;
            c.b = 0;
        }
        return c;
    }

    function createColorScale(n){
      var colorScale = [];
      for(let i=0;i<n;i++){
        var c = getColor(i/(n-1),0,1,1);
        var rgbStr = 'rgb('+Math.floor(c.r*255)+','+Math.floor(c.g*255)+','+Math.floor(c.b*255)+')';
        colorScale.push([i/(n-1),rgbStr]);
      }
      return colorScale;
    }

    var rdata = {};
    var rangeMax = 3000;
    var rangeMin = 0;
    var vMax = 10000;
    var vMin = 0;
    var colorOpacity = 0.5;
    var rangeScale = 1;
    var scal = 1;
    var resolution = 15;
    var locations = [];
    var drawData = [];
    var timeat=[];
    var heights = [];
    var lines, points3D;
    var layoutA = {
        xaxis: {
            title: '时间',
            showline: true,
            tickmode:'auto',
            showspikes: true,
            spikemode: 'across'
        },
        yaxis: {
            title: '距离(m)',
            showline: true,
            range:[0,3000],
            // fixedrange:true
        }
    };

    $.post('{{ url_for('main.get_mov_data') }}', { 'task id': task_id},
          function(data,status){
            var channel = document.getElementById('channel');
            channel.addEventListener("change", SelectChannel);
            var colorMax = document.getElementById('colorMax');
            colorMax.addEventListener("change", ChangeMaxValue);
            var colorMin = document.getElementById('colorMin');
            colorMin.addEventListener("change", ChangeMinValue);
            var zMax = document.getElementById('zMax');
            zMax.addEventListener("change", ChangeRangeMax);
            var zMin = document.getElementById('zMin');
            zMin.addEventListener("change", ChangeRangeMin);
            var opacity = document.getElementById('opacity');
            opacity.addEventListener("change", ChangeColorOpacity);
            var scale = document.getElementById('scale');
            scale.addEventListener("change", ChangeRangeScale);

            rdata.raw_A = [];
            rdata.raw_B = [];
            rdata.prr_A = [];
            rdata.prr_B = [];
            rdata.ext = [];
            rdata.dep = [];
            rdata.pbl = [];
            resolution = data.result[0].resolution;
            var leng = data.result[0].raw_A.length;        
            for(let i = 0;i<leng;i++){
                heights.push((i+1)*resolution);
            };
            for(let i=0; i<data.result.length;i++){
                if(data.result[i].longitude>-180){
                    timeat.push(data.result[i].timestamp);
                    rdata.prr_A.push(data.result[i].prr_A);
                    rdata.prr_B.push(data.result[i].prr_B);
                    rdata.raw_A.push(data.result[i].raw_A);
                    rdata.raw_B.push(data.result[i].raw_B);
                    rdata.ext.push(data.result[i].ext);
                    rdata.dep.push(data.result[i].dep);
                    rdata.pbl.push(data.result[i].pbl);
                    var longitude = data.result[i].longitude;
                    var latitude = data.result[i].latitude;
                    var altitude = data.result[i].altitude;
                    locations.push(Gps84ToGcj02(longitude,latitude));
                }             
            };
            drawData = rdata.prr_A;
            createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);
            map.setCenter(locations[0]);
            map.setFitView();
            createWallIndicator();

            var PRA_data = [
                {
                z: drawData,
                x: timeat,
                y: heights,
                zmin: 0,
                zmax: 10000,
                type: 'heatmap',
                transpose: true,
                colorscale:createColorScale(11),
                colorbar:{thickness:15,xpad:5}
                }
            ];

            Plotly.newPlot('PRADiv', PRA_data, layoutA);
            plotA.on('plotly_hover',plotHover);
        });

    function createWallIndicator(){
      var center = map.lngLatToGeodeticCoord(locations[lineIndex]);
      lines = new AMap.Object3D.Line();
      var lineGeo = lines.geometry;
      points3D = new AMap.Object3D.RoundPoints();
      points3D.transparent = true;
      var pointsGeo = points3D.geometry;
      var height = scal*rangeMax;
      // 连线
      lineGeo.vertices.push(center.x, center.y, 0);
      lineGeo.vertexColors.push(0, 1, 1, 1);
      lineGeo.vertices.push(center.x, center.y, -height);
      lineGeo.vertexColors.push(0, 1, 1, 1);

      pointsGeo.vertices.push(center.x, center.y, 0); // 尾部小点
      pointsGeo.pointSizes.push(5);
      pointsGeo.vertexColors.push(0, 0, 1, 1);

      pointsGeo.vertices.push(center.x, center.y, -height); // 空中点
      pointsGeo.pointSizes.push(20);
      pointsGeo.vertexColors.push(2 * 0.029, 2 * 0.015, 2 * 0.01, 1);

      points3D.borderColor = [0.4, 0.8, 1, 1];
      points3D.borderWeight = 3;
      object3Dlayer.add(lines);
      object3Dlayer.add(points3D);
    }


    var lineIndex = 0;
    var plotA = document.getElementById('PRADiv');
    function plotHover(data){
      var pn='';
      for(let i=0;i<data.points.length;i++){
        if(data.points[i].fullData.type==='heatmap'){
          pn = data.points[i].pointNumber;
        }
      }
      lineIndex = pn[1];
      var center = map.lngLatToGeodeticCoord(locations[lineIndex]);
      var height = scal*rangeMax;
      lines.geometry.vertices = [];
      lines.geometry.vertices.push(center.x, center.y, 0);
      lines.geometry.vertices.push(center.x, center.y, -height);
      lines.needUpdate = true;

      points3D.geometry.vertices = [];
      points3D.geometry.vertices.push(center.x, center.y, 0); // 尾部小点
      points3D.geometry.vertices.push(center.x, center.y, -height); // 空中点
      points3D.needUpdate = true;
      lines.reDraw();
      points3D.reDraw();

    }

    function Gps84ToGcj02(lon,lat){
      if (outOfChina(lon, lat)) {
            return new AMap.LngLat(lon, lat);
      }
      let a = 6378245.0;
      let ee = 0.00669342162296594323;
      let dLat = TransformLat(lon - 105.0, lat - 35.0);
      let dLon = TransformLon(lon - 105.0, lat - 35.0);
      let radLat = lat / 180.0 * Math.PI;
      let magic = Math.sin(radLat);
      magic = 1 - ee * magic * magic;
      let sqrtMagic = Math.sqrt(magic);
      dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * Math.PI);
      dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI);
      let mgLat = lat + dLat;
      let mgLon = lon + dLon;
      return new AMap.LngLat(mgLon, mgLat);
    }

    function outOfChina(lon, lat) {
        if (lon < 72.004 || lon > 137.8347)
            return true;
        if (lat < 0.8293 || lat > 55.8271)
            return true;
        return false;
    }

    function TransformLat(x,y){
      var ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
      ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
      ret += (20.0 * Math.sin(y * Math.PI) + 40.0 * Math.sin(y / 3.0 * Math.PI)) * 2.0 / 3.0;
      ret += (160.0 * Math.sin(y / 12.0 * Math.PI) + 320 * Math.sin(y * Math.PI / 30.0)) * 2.0 / 3.0;
      return ret;
    }

    function TransformLon(x,y){
      var ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
      ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
      ret += (20.0 * Math.sin(x * Math.PI) + 40.0 * Math.sin(x / 3.0 * Math.PI)) * 2.0 / 3.0;
      ret += (150.0 * Math.sin(x / 12.0 * Math.PI) + 300.0 * Math.sin(x / 30.0 * Math.PI)) * 2.0 / 3.0;
      return ret;
    }

    function SelectChannel(){
        drawData = rdata.prr_A;
        var line = {};
        var channel = document.getElementById('channel');
        switch(channel.options[channel.selectedIndex].text){
          case '平行通道距离校正信号':
            drawData = rdata.prr_A;
            break;
          case '垂直通道距离校正信号':
            drawData = rdata.prr_B;
            break;
          case '消光系数':
            drawData = rdata.ext;
            break;
          case '退偏比':
            drawData = rdata.dep;
            break;
          case '平行通道原始信号':
            drawData = rdata.raw_A;
            break;
          case '垂直通道原始信号':
            drawData = rdata.raw_B;
            break;
          case '污染边界层':
            drawData = rdata.prr_A;
            line = {
              x:timeat,
              y:rdata.pbl,
              mode:'markers',
              type:'scatter',
              marker:{color:'black'}
            };
            break;
        };
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);
        createWallIndicator();

        var heat = {
              z: drawData,
              x: timeat,
              y: heights,
              zmin: vMin,
              zmax: vMax,
              type: 'heatmap',
              transpose: true,
              colorscale:createColorScale(11),
              colorbar:{thickness:15,xpad:5}
            };
        
        var data = [heat,line];
        Plotly.react('PRADiv',data,layoutA);
      }

      function ChangeMaxValue(){
        var colorMax = document.getElementById('colorMax');
        vMax = Number(colorMax.value);
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);
        createWallIndicator();

        var update = {
          zmax:vMax
        };
        Plotly.restyle('PRADiv',update);
      }

      function ChangeMinValue(){
        var colorMin = document.getElementById('colorMin'); 
        vMin = Number(colorMin.value);  
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);
        createWallIndicator(); 

        var update = {
          zmin:vMin
        };
        Plotly.restyle('PRADiv',update); 

      }

      function ChangeRangeMax(){
        var zMax = document.getElementById('zMax'); 
        rangeMax = Number(zMax.value);  
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity); 
        createWallIndicator();
        
        layoutA.yaxis.range[1] = rangeMax;
        var update = {
          'yaxis.range[1]':rangeMax
        };
        Plotly.relayout('PRADiv',update);
      }

      function ChangeRangeMin(){
        var zMin = document.getElementById('zMin'); 
        rangeMin = Number(zMin.value);  
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity); 
        createWallIndicator();
        
        layoutA.yaxis.range[0] = rangeMin;
        var update = {
          'yaxis.range[0]':rangeMin
        };
        Plotly.relayout('PRADiv',update);
      }

      function ChangeColorOpacity(){
        var opacity = document.getElementById('opacity'); 
        colorOpacity = Number(opacity.value);  
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);  
        createWallIndicator();
      }

      function ChangeRangeScale(){
        var scale = document.getElementById('scale'); 
        rangeScale = Number(scale.value);  
        object3Dlayer.clear();
        createWall(locations,drawData,resolution,rangeMin,rangeMax,rangeScale,vMin,vMax,colorOpacity);   
        createWallIndicator();
      }

</script>



{% endblock %}