{% extends "base.html" %}

{% block app_content %}
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
  <link rel="stylesheet" href="../static/main1119.css"/>
  <script src="../static/es5.min.js"></script>
  <script src="../static/maps.js"></script>
  <script src="../static/html2canvas.min.js"></script>
  <!-- UI组件库 1.0 -->
  <script src="../static/main.js"></script>
</head>
<style type="text/css">
    .inputNum {
      width: 4em;
      text-align: right;
    }
    #viewDiv {
      height: 800px;
    }
    #info {
      background-color:whitesmoke;
      z-index: 100;
      position: absolute; 
      bottom: 0;
      right: 0;
    }
    #colorbar{
      z-index: 100;
      position: absolute; 
      bottom: 60px;
      right: 10px;
    }
    #setCenter{
      z-index: 100;
      position: absolute;
      right: 31px;
      top: 70px;
      border-radius: 3px;
      background-color: white;
    }
    #addMarker{
      z-index: 100;
      position: absolute;
      right: 31px;
      top: 107px;
      border-radius: 3px;
      background-color: white;
    }
    #addRuler{
      z-index: 100;
      position: absolute;
      right: 31px;
      top: 144px;
      border-radius: 3px;
      background-color: white;
    }
    #addMeasurer{
      z-index: 100;
      position: absolute;
      right: 31px;
      top: 181px;
      border-radius: 3px;
      background-color: white;
    }
    #clearOverlay{
      z-index: 100;
      position: absolute;
      right: 31px;
      top: 218px;
      border-radius: 3px;
      background-color: white;
    }
    #savePic{
      z-index: 100;
      position: absolute;
      right: 31px;
      top: 255px;
      border-radius: 3px;
      background-color: white;
    }
    /* .html2canvas-container { width: 1500px !important; height: 1500px !important; } */
</style>
 <select class = 'tS' id="timeSeries">

 </select>
  <select  class = 'ch' id="channel">
    <option>平行通道距离校正信号</option>
    <option>垂直通道距离校正信号</option>
    <option>消光系数</option>
    <option>退偏比</option>
    <option>平行通道原始信号</option>
    <option>垂直通道原始信号</option>
    <option>PM10</option>
    <option>PM2.5</option>
  </select>
  <span>
    &nbsp;&nbsp;&nbsp;&nbsp;从<input type="number" id="zMin" value="0" class="inputNum" max="30000" min="15">
    至<input type="number" id="zMax" value="6000" class="inputNum" max="30000" min="15">&nbsp;&nbsp;&nbsp;&nbsp;
  </span>
  <span>
    色标最小值<input type="number" id="colorMin" value="0" class="inputNum">
    色标最大值<input type="number" id="colorMax" value="10000" class="inputNum">&nbsp;&nbsp;&nbsp;&nbsp;
    透明度<input type="number" id="opacity" value="0.5" class="inputNum">
  </span>
  
<div id="viewDiv" class = "map">
  <div id="colorbar">
      <canvas id="canvas" width="50" height="260"></canvas>
  </div>
  <div class="input-card" id = "info">  
    <div class="input-item">
      <span id="angleRange"></span>
    </div>
    <div class="input-item">
      <span id="angleStep"></span>
    </div>
    <div class="input-item">
      <span id="angleVer"></span>
    </div>
  </div>
  <input id="setCenter" type="image" title="居中" src="../static/setCenter.png" onclick="setMapCenter()"/>
  <input id="addMarker" type="image" title="添加标记" src="../static/marker.png" onclick="addMapMarker()"/>
  <input id="addRuler" type="image" title="距离测量" src="../static/ruler.png" onclick="addMapRuler()"/>
  <input id="addMeasurer" type="image" title="面积测量" src="../static/measurer.png" onclick="addMapMeasurer()"/>
  <input id="clearOverlay" type="image" title="清除" src="../static/clear.png" onclick="clearMapOverlay()"/>
  <input id="savePic" type="image" title="保存图片" src="../static/savePic.png" onclick="saveMap()"/>
</div>

{% endblock %}

{% block app_scripts %}

<script type="text/javascript">
    var task_id = '{{task_id}}';

    function setMapCenter(){
      map.setCenter(position);
    }

    function saveMap(){
      html2canvas(document.getElementById('viewDiv')).then(function(canvas) {
        var myImage = canvas.toBlob(function(blob){
        var link = document.createElement("a");
          if (link.download !== undefined) { // feature detection
              // Browsers that support HTML5 download attribute
              var url = URL.createObjectURL(blob);
              var channel = document.getElementById('channel');
              var sel1 = document.getElementById('timeSeries');
              link.setAttribute("href", url);
              link.setAttribute("download", channel.options[channel.selectedIndex].text+sel1.options[sel1.selectedIndex].text+".png");
              link.style.visibility = 'hidden';
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
          }
        });
      });
    }

    function drawColorbar(n) {
      var canvas = document.getElementById("canvas");
        width = canvas.width;
        height = canvas.height;

        var ctx = canvas.getContext("2d");

        // Create the linear gradient with which to fill the canvas
        var gradient = ctx.createLinearGradient(0, 10, 0, 250);
        for(let i=0;i<n;i++){
          var c = getColor(i/(n-1),0,1,1);
          var rgbStr = 'rgb('+Math.floor(c.r*255)+','+Math.floor(c.g*255)+','+Math.floor(c.b*255)+')';
          gradient.addColorStop(1-i/(n-1), rgbStr);
        }
        // Fill the canvas with the gradient pattern
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 10, 10, 240);
}
var tickColor = 'black';
var textColor = 'black';

    function drawTicks(){
      var canvas = document.getElementById("canvas");
      var ctx = canvas.getContext("2d");
      ctx.clearRect(10,0,canvas.width,canvas.height);
      ctx.strokeStyle = tickColor;
      for (let i = 0;i<6;i++){
        ctx.beginPath();
        ctx.moveTo(10,10+i*48);
        ctx.lineTo(15,10+i*48);
        ctx.stroke();
      }
    }

    function drawTickText(){
      var canvas = document.getElementById("canvas");
      var ctx = canvas.getContext("2d");
      ctx.clearRect(16,0,canvas.width,canvas.height);
      let dv = (vMax-vMin)/5;
      ctx.fillStyle = textColor;
      for (let i = 0;i<6;i++){
        ctx.fillText((vMax-i*dv).toExponential(1),16,10+i*48);
      }
    }

drawColorbar(11);
drawTicks();
var vMax = 10000;
var vMin = 0;
drawTickText();

    var map = new AMap.Map('viewDiv', {
        viewMode:'3D',  
        expandZoomRange:true,
        zooms:[3,20],
        zoom:16,
        pitch:0,
        center:[116.396132,39.900444]
    });

    var geocoder;

    var object3Dlayer = new AMap.Object3DLayer();
    map.add(object3Dlayer);

    // var heatmapLayer = new Loca.HeatmapLayer({
    //     map: map,
    // });

    AMapUI.loadUI(['control/BasicControl'], function(BasicControl) {
      var layerCtrl = new BasicControl.LayerSwitcher({
          position: 'rt',
          
           //自定义基础图层
            baseLayers: [{
                enable: true,
                id: 'Gtile',
                name: '谷歌矢量图',
                layer: new AMap.TileLayer({
                  getTileUrl: 'http://mt{1,2,3,0}.google.cn/vt/lyrs=m@126&hl=zh-CN&gl=cn&src=app&s=G&x=[x]&y=[y]&z=[z]',
                  zIndex:2
                })
            },{
                id: 'Gsatellite',
                name: '谷歌卫星图',
                layer: new AMap.TileLayer({
                  getTileUrl: 'http://mt{1,2,3,0}.google.cn/vt/lyrs=y@126&hl=zh-CN&gl=cn&src=app&s=G&x=[x]&y=[y]&z=[z]',
                  zIndex:2
                })
            },{
                id: 'Atile',
                name: '高德矢量图',
                layer: new AMap.TileLayer()
            }, {
                id: 'Asatellite',
                name: '高德卫星图',
                layer: new AMap.TileLayer.Satellite()
             }],
            //自定义覆盖图层
            overlayLayers: [ {
                id: 'roadNet',
                name: '高德路网图',
                layer: new AMap.TileLayer.RoadNet()
            },{
                enable: true,
                id: 'object3D',
                name: '雷达扫描图',
                layer: object3Dlayer
            }]
      });
      //图层切换控件
      map.addControl(layerCtrl);
      map.setLayers(layerCtrl.getEnabledLayers());
      layerCtrl.on('layerPropChanged',function(e){
        if(e.props.enable){
          if(e.layer.id.includes('satellite')){
            tickColor = '#FFF';
            textColor = '#FFF';
            drawTicks();
            drawTickText();
          }else if(e.layer.id.includes('tile')){
            tickColor = '#000';
            textColor = '#000';
            drawTicks();
            drawTickText();
          };
        };
      });
    });

    AMap.plugin([
        'AMap.ControlBar',
        'AMap.Scale'
    ], function(){

        // 添加 3D 罗盘控制
        map.addControl(new AMap.ControlBar({
            position: {left:'-90px'} 
        }));
        map.addControl(new AMap.Scale());
    });

    var rdata = {};
    var rangeMax = 6000;
    var colorOpacity = 0.5;
    var resolution = 15;
    var verAng = 0;
    var horAngStart=0;
    var horAngEnd = 360;
    var horAngStep = 5;
    var longitude = 0;
    var latitude = 0;
    var altitude = 0;
    var drawData = [];
    var position = new AMap.LngLat(0, 0);

    function createPie(location,drawData,resolution,rangeMax,verAng,horAngStart,horAngEnd,horAngStep,vMin,vMax,opacity) {
        var gpn = Math.floor((horAngEnd-horAngStart)/horAngStep);
        for(var i = 0;i<gpn;i++){
            var tri = generateTriangle(location,rangeMax,resolution,i,drawData,verAng,horAngStart+i*horAngStep,horAngStart+(i+1)*horAngStep,vMin,vMax,opacity);
            object3Dlayer.add(tri);
        }
    }

    function generateTriangle(lnglat, r, resl, idata, rdata, verAng, horAngStart, horAngEnd, vmin, vmax, alpha){
        var v0xy = map.lngLatToGeodeticCoord(lnglat);
        var v1xy = map.lngLatToGeodeticCoord(lnglat.offset(5000,0));
        var scal = (v1xy.x-v0xy.x)/5000;
        var x0 = v0xy.x;
        var y0 = v0xy.y;
        var z0 = 0;

        var x1 = [], y1 = [],z1 = [], x2 = [], y2 = [], z2 = [];
        var nmax = r/resl;
        resl *= scal;
        for(var i = 0; i<nmax+1; i++){
          x1.push(x0+i*resl*Math.cos(verAng/180*Math.PI)*Math.sin(horAngStart/180*Math.PI));
          y1.push(y0-i*resl*Math.cos(verAng/180*Math.PI)*Math.cos(horAngStart/180*Math.PI));
          z1.push(z0-i*resl*Math.sin(verAng/180*Math.PI));
          x2.push(x0+i*resl*Math.cos(verAng/180*Math.PI)*Math.sin(horAngEnd/180*Math.PI));
          y2.push(y0-i*resl*Math.cos(verAng/180*Math.PI)*Math.cos(horAngEnd/180*Math.PI));
          z2.push(z0-i*resl*Math.sin(verAng/180*Math.PI));
        }

        var triangle = new AMap.Object3D.Mesh()
        triangle.transparent = true;
        triangle.backOrFront = 'both';

        var geometry = triangle.geometry;
        for(var i = 0; i<nmax; i++){
          geometry.vertices.push(x1[i], y1[i], z1[i]);
          geometry.vertices.push(x1[i+1], y1[i+1], z1[i+1]);
          geometry.vertices.push(x2[i+1], y2[i+1], z2[i+1]);
          geometry.vertices.push(x1[i], y1[i], z1[i]);
          geometry.vertices.push(x2[i], y2[i], z2[i]);
          geometry.vertices.push(x2[i+1], y2[i+1], z2[i+1]);
          var xc1 = getColor(rdata[idata][i], vmin, vmax, alpha);
          var xc2 = getColor(rdata[idata][i+1], vmin, vmax, alpha);
          var xc3 = getColor(rdata[idata+1][i], vmin, vmax, alpha);
          var xc4 = getColor(rdata[idata+1][i+1], vmin, vmax, alpha);
          geometry.vertexColors.push(xc1.r, xc1.g, xc1.b, xc1.a);
          geometry.vertexColors.push(xc2.r, xc2.g, xc2.b, xc2.a);
          geometry.vertexColors.push(xc4.r, xc4.g, xc4.b, xc4.a);
          geometry.vertexColors.push(xc1.r, xc1.g, xc1.b, xc1.a);
          geometry.vertexColors.push(xc3.r, xc3.g, xc3.b, xc3.a);
          geometry.vertexColors.push(xc4.r, xc4.g, xc4.b, xc4.a);
        }
        
        
        return triangle;
    }

    function getColor(v, vmin, vmax, alpha){
        var c = {};
        if (v < vmin){
          v = vmin;
        }          
        if (v > vmax){
          v = vmax;
        }
        var dv = vmax - vmin;
        c.a = alpha-0.1+0.2*(v - vmin) / dv;

        if (v < (vmin + 0.25 * dv)) {
            var g = 4 * (v - vmin) / dv;
            c.r = 0;
            c.g = g;
            c.b = 1;
        } else if (v < (vmin + 0.5 * dv)) {
            var b = 1 + 4 * (vmin + 0.25 * dv - v) / dv;
            c.r = 0;
            c.g = 1;
            c.b = b;
        } else if (v < (vmin + 0.75 * dv)) {
            var r = 4 * (v - vmin - 0.5 * dv) / dv;
            c.r = r;
            c.g = 1;
            c.b = 0;
        } else {
            var g = 1 + 4 * (vmin + 0.75 * dv - v) / dv;
            c.r = 1;
            c.g = g;
            c.b = 0;
        }
        return c;
  }

  function create3DHeatmap(){
    var list = [];
    var v0xy = map.lngLatToGeodeticCoord(position);
    var v1xy = map.lngLatToGeodeticCoord(position.offset(5000,0));
    var scal = (v1xy.x-v0xy.x)/5000;
    var x0 = v0xy.x;
    var y0 = v0xy.y;
    for (let i = 0;i<drawData.length;i++) {
      let horAng = horAngStart+i*horAngStep;
      for(let j = 0;j<rangeMax/resolution;j++){        
        x1 = (x0+j*resolution*scal*Math.cos(verAng/180*Math.PI)*Math.sin(horAng/180*Math.PI));
        y1 = (y0-j*resolution*scal*Math.cos(verAng/180*Math.PI)*Math.cos(horAng/180*Math.PI));
        let ll = map.geodeticCoordToLngLat(new AMap.Pixel(x1,y1));
        list.push({
            coordinate: [ll.lng, ll.lat],
            count: drawData[i][j]
        })
      }
    

    }

    heatmapLayer.setData(list, {
        lnglat: 'coordinate',
        value: 'count'
    });

    heatmapLayer.setOptions({
        style: {
            radius: 30,
            color: {
                0.5: '#2c7bb6',
                0.65: '#abd9e9',
                0.7: '#ffffbf',
                0.9: '#fde468',
                1.0: '#d7191c'
            }
        }
    });

    heatmapLayer.render();
  }

  function prepareData(data){
    rdata.raw_A = [];
    rdata.raw_B = [];
    rdata.prr_A = [];
    rdata.prr_B = [];
    rdata.ext = [];
    rdata.dep = [];
    rdata.pm10 = [];
    rdata.pm25 = [];
    resolution = data.result[0].resolution;
    verAng = data.result[0].verAngle;
    horAngStart = data.result[0].horAngle;
    horAngEnd = data.result[data.result.length-1].horAngle;
    horAngStep = data.result[1].horAngle - data.result[0].horAngle;
    let lonArr = [];
    let latArr = [];
    let altArr = [];
    for(let i=0; i<data.result.length;i++){
      if(data.result[i].longitude>0){
        lonArr.push(data.result[i].longitude);
        latArr.push(data.result[i].latitude);
        altArr.push(data.result[i].altitude);
    }; 
    };
    lonArr.sort(function(a,b){return a-b});
    latArr.sort(function(a,b){return a-b});
    altArr.sort(function(a,b){return a-b});
    longitude = lonArr[Math.floor(lonArr.length/2)];
    latitude = latArr[Math.floor(lonArr.length/2)];
    altitude = altArr[Math.floor(lonArr.length/2)];
    position = Gps84ToGcj02(longitude,latitude);
    for(let i=0; i<data.result.length;i++){
        rdata.prr_A.push(data.result[i].prr_A);
        rdata.prr_B.push(data.result[i].prr_B);
        rdata.raw_A.push(data.result[i].raw_A);
        rdata.raw_B.push(data.result[i].raw_B);
        rdata.ext.push(data.result[i].ext);
        rdata.dep.push(data.result[i].dep);
        rdata.pm10.push(data.result[i].ext.map(x => x>0? 243*Math.pow(x,1.13) : 0));
        rdata.pm25.push(data.result[i].ext.map(x => x>0? 121.5*Math.pow(x,1.13) : 0));
    };
  }
    $.post('{{ url_for('main.get_ppi_data') }}', { 'task id': task_id, 'content':'list' },
        function(data,status){
        var sel1 = document.getElementById('timeSeries');
        sel1.addEventListener("change", SelectTime);
        var channel = document.getElementById('channel');
        channel.addEventListener("change", SelectChannel);
        var colorMax = document.getElementById('colorMax');
        colorMax.addEventListener("change", ChangeMaxValue);
        var colorMin = document.getElementById('colorMin');
        colorMin.addEventListener("change", ChangeMinValue);
        var zMax = document.getElementById('zMax');
        zMax.addEventListener("change", ChangeRangeMax);
        var opacity = document.getElementById('opacity');
        opacity.addEventListener("change", ChangeColorOpacity);
        for(let i=0; i<data.result.length;i++){
            sel1.options.add(new Option(data.result[i].timestamp+""));
        };
        $.post('{{ url_for('main.get_ppi_data') }}', { 'task id': task_id, 'content':'timedata', 'time': sel1.options[0].text},
            function(data,status){
            prepareData(data);
            drawData = rdata.prr_A;
            createPie(position,drawData,resolution,rangeMax,verAng,horAngStart,horAngEnd,horAngStep,vMin,vMax,colorOpacity);
            map.setCenter(position);
            map.setFitView();

            document.getElementById('angleRange').textContent = "扫描范围"+horAngStart+" - "+horAngEnd;
            document.getElementById('angleStep').textContent = "扫描步长"+horAngStep;
            document.getElementById('angleVer').textContent = "垂直角度"+verAng;
        });
    });

    var mouseTool = new AMap.MouseTool(map); 

    function addMapMarker(){
      mouseTool.marker();
    }

    function clearMapOverlay(){
      mouseTool.close(true);
    }

    function addMapRuler(){
      mouseTool.rule();
    }

    function addMapMeasurer(){
      mouseTool.measureArea();
    }
    
    var overlays = [];
    mouseTool.on('draw',function(e){
        var overlay = e.obj;  
        if(overlay.CLASS_NAME=='AMap.Marker'){
          var location = overlay.getPosition();
          var dis = AMap.GeometryUtil.distance(location, position);
          var rn = Math.round(dis/resolution/Math.cos(verAng/180*Math.PI));
          var p0 = map.lngLatToGeodeticCoord(position);
          var p1 = map.lngLatToGeodeticCoord(location);
          var ang = (Math.atan2(p1.y-p0.y,p1.x-p0.x)/Math.PI*180+450)%360;
          var angDiff = ang-horAngStart;
          angDiff<0 && (angDiff+=360);
          var an = Math.floor(angDiff/horAngStep);

          if(!geocoder){
              geocoder = new AMap.Geocoder({
                  city: "010", //城市设为北京，默认：“全国”
                  radius: 1000 //范围，默认：500
              });
          } 
          geocoder.getAddress(location, function(status, result) {
              if (status === 'complete'&&result.regeocode) {
                  var address = result.regeocode.formattedAddress;
                  overlay.setLabel({
                      offset: new AMap.Pixel(0, -3),  //设置文本标注偏移量
                      content: "<div><div>当前位置"+location.lng + ',' + location.lat+"</div>"+
                              "<div class='info'>"+address+"</div>"+
                              "<div class='info'>距离"+Math.round(dis)+"</div>"+
                              "<div class='info'>角度"+Math.round(ang)+"</div>"+
                              "<div class='info'>数值"+drawData[an][rn].toFixed(2)+"</div></div>",
                      direction: 'top' //设置文本标注方位
                  });
              }else{
                  log.error('根据经纬度查询地址失败')
              }
          });

        }
    }) 
    
    function Gps84ToGcj02(lon,lat){
      if (outOfChina(lon, lat)) {
            return new AMap.LngLat(lon, lat);
      }
      let a = 6378245.0;
      let ee = 0.00669342162296594323;
      let dLat = TransformLat(lon - 105.0, lat - 35.0);
      let dLon = TransformLon(lon - 105.0, lat - 35.0);
      let radLat = lat / 180.0 * Math.PI;
      let magic = Math.sin(radLat);
      magic = 1 - ee * magic * magic;
      let sqrtMagic = Math.sqrt(magic);
      dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * Math.PI);
      dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI);
      let mgLat = lat + dLat;
      let mgLon = lon + dLon;
      return new AMap.LngLat(mgLon, mgLat);
    }

    function outOfChina(lon, lat) {
        if (lon < 72.004 || lon > 137.8347)
            return true;
        if (lat < 0.8293 || lat > 55.8271)
            return true;
        return false;
    }

    function TransformLat(x,y){
      var ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
      ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
      ret += (20.0 * Math.sin(y * Math.PI) + 40.0 * Math.sin(y / 3.0 * Math.PI)) * 2.0 / 3.0;
      ret += (160.0 * Math.sin(y / 12.0 * Math.PI) + 320 * Math.sin(y * Math.PI / 30.0)) * 2.0 / 3.0;
      return ret;
    }

    function TransformLon(x,y){
      var ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
      ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;
      ret += (20.0 * Math.sin(x * Math.PI) + 40.0 * Math.sin(x / 3.0 * Math.PI)) * 2.0 / 3.0;
      ret += (150.0 * Math.sin(x / 12.0 * Math.PI) + 300.0 * Math.sin(x / 30.0 * Math.PI)) * 2.0 / 3.0;
      return ret;
    }

    function SelectTime(){
        var sel1 = document.getElementById('timeSeries');
        var index = sel1.selectedIndex;
        $.post('{{ url_for('main.get_ppi_data') }}', { 'task id': task_id, 'content':'timedata', 'time': sel1.options[index].text},
        function(data,status){
          prepareData(data);
          SelectChannel();
        });      
      }

      function SelectChannel(){
        drawData = rdata.prr_A;
        var channel = document.getElementById('channel');
        switch(channel.options[channel.selectedIndex].text){
          case '平行通道距离校正信号':
            drawData = rdata.prr_A;
            break;
          case '垂直通道距离校正信号':
            drawData = rdata.prr_B;
            break;
          case '消光系数':
            drawData = rdata.ext;
            break;
          case '退偏比':
            drawData = rdata.dep;
            break;
          case '平行通道原始信号':
            drawData = rdata.raw_A;
            break;
          case '垂直通道原始信号':
            drawData = rdata.raw_B;
            break;
          case 'PM10':
            drawData = rdata.pm10;
            break;
          case 'PM2.5':
            drawData = rdata.pm25;
            break;
        };
        object3Dlayer.clear();
        createPie(position,drawData,resolution,rangeMax,verAng,horAngStart,horAngEnd,horAngStep,vMin,vMax,colorOpacity);
      }

      function ChangeMaxValue(){
        var colorMax = document.getElementById('colorMax');
        vMax = Number(colorMax.value);
        object3Dlayer.clear();
        createPie(position,drawData,resolution,rangeMax,verAng,horAngStart,horAngEnd,horAngStep,vMin,vMax,colorOpacity);
        drawTickText();
      }

      function ChangeMinValue(){
        var colorMin = document.getElementById('colorMin'); 
        vMin = Number(colorMin.value);  
        object3Dlayer.clear();
        createPie(position,drawData,resolution,rangeMax,verAng,horAngStart,horAngEnd,horAngStep,vMin,vMax,colorOpacity); 
        drawTickText(); 
      }

      function ChangeRangeMax(){
        var zMax = document.getElementById('zMax'); 
        rangeMax = Number(zMax.value);  
        object3Dlayer.clear();
        createPie(position,drawData,resolution,rangeMax,verAng,horAngStart,horAngEnd,horAngStep,vMin,vMax,colorOpacity);   
      }

      function ChangeColorOpacity(){
        var opacity = document.getElementById('opacity'); 
        colorOpacity = Number(opacity.value);  
        object3Dlayer.clear();
        createPie(position,drawData,resolution,rangeMax,verAng,horAngStart,horAngEnd,horAngStep,vMin,vMax,colorOpacity);   
      }


</script>



{% endblock %}