{% extends "base.html" %}

{% block app_content %}
<style type="text/css">
    .inputNum {
      width: 6em;
      text-align: right;
    }
    #viewDiv {
      height: 800px;
    }
</style>
 <select id="timeSeries">

 </select>
  <select  id="channel">
          <option>平行通道距离校正信号</option>
          <option>垂直通道距离校正信号</option>
          <option>消光系数</option>
          <option>退偏比</option>
          <option>平行通道原始信号</option>
          <option>垂直通道原始信号</option>
        </select>
        <span>
          &nbsp;&nbsp;&nbsp;&nbsp;从<input type="number" id="zMin" value="0" class="inputNum" max="30000" min="15">
          至<input type="number" id="zMax" value="6000" class="inputNum" max="30000" min="15">&nbsp;&nbsp;&nbsp;&nbsp;
        </span>
        <span>
          色标最小值<input type="number" id="colorMin" value="0" class="inputNum">
          色标最大值<input type="number" id="colorMax" value="10000" class="inputNum">
        </span>
  
  <div id="viewDiv"></div>

{% endblock %}

{% block app_scripts %}
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
    <link rel="stylesheet" href="https://cache.amap.com/lbs/static/main1119.css"/>
    <script src="https://cache.amap.com/lbs/static/es5.min.js"></script>
    <script src="https://webapi.amap.com/maps?v=1.4.14&key=deccd88e5fc1ec27d19c67f6790c1c88&plugin=Map3D"></script>
</head>
<script>
    var task_id = '{{task_id}}';

    var map = new AMap.Map('viewDiv', {
        viewMode:'3D',  
        expandZoomRange:true,
        zooms:[3,20],
        zoom:16,
        pitch:0,
        center:[116.396132,39.900444]
    });
    var object3Dlayer = new AMap.Object3DLayer();
    // map.plugin(["AMap.Scale"],function(){
    //     var scale = new AMap.Scale();
    //     map.addControl(scale);   
    // });

    var rdata = {};
    var rangeMax = 6000;
    var vMax = 10000;
    var vMin = 0;
    var resolution = 15;
    var verAng = 0;
    var horAngStart=0;
    var horAngEnd = 360;
    var horAngStep = 5;
    var longitude = 0;
    var latitude = 0;
    var altitude = 0;
    var drawData = [];

    function createPie(location,drawData,resolution,rangeMax,verAng,horAngStart,horAngEnd,horAngStep,vMin,vMax) {
        var gpn = Math.floor((horAngEnd-horAngStart)/horAngStep);
        for(var i = 0;i<gpn;i++){
            var tri = generateTriangle(location,rangeMax,resolution,drawData[i],verAng,horAngStart+i*horAngStep,horAngStart+(i+1)*horAngStep,vMin,vMax);
            object3Dlayer.add(tri);
        }
    }

    function generateTriangle(lnglat, r, resl, rdata, verAng, horAngStart, horAngEnd, vmin, vmax){
        var v0xy = map.lngLatToGeodeticCoord(lnglat);
        var x0 = v0xy.x;
        var y0 = v0xy.y;
        var z0 = 0;
        var x1,y1,z1,x2,y2,z2;

        var triangle = new AMap.Object3D.Mesh()
        triangle.transparent = true;
        var geometry = triangle.geometry;
        var dz = r*Math.sin(verAng/180*Math.PI);
        geometry.vertices.push(x0, y0, z0);
        x1 = x0+r*Math.cos(verAng/180*Math.PI)*Math.sin(horAngStart/180*Math.PI);
        y1 = y0-r*Math.cos(verAng/180*Math.PI)*Math.cos(horAngStart/180*Math.PI);
        z1 = z0-dz;
        geometry.vertices.push(x1, y1, z1);
        x2 = x0+r*Math.cos(verAng/180*Math.PI)*Math.sin(horAngEnd/180*Math.PI);
        y2 = y0-r*Math.cos(verAng/180*Math.PI)*Math.cos(horAngEnd/180*Math.PI);
        z2 = z0-dz;
        geometry.vertices.push(x2, y2, z2);
        geometry.faces.push(0, 1, 2);
        geometry.vertexUVs.push(0.5, 0); 
        geometry.vertexUVs.push(0, 0.99); 
        geometry.vertexUVs.push(1, 0.99);

        var nmax = r/resl;
        var texture = createTriangleTexture(rdata,nmax,vmin,vmax);        
        triangle.textures.push(texture);
        triangle.backOrFront = 'both';
        return triangle;
    }

    function createTriangleTexture(points, nmax, vmin, vmax) {
        var canvas = document.createElement("canvas");
        width = 16;
        height = 512;
        canvas.width = width;
        canvas.height = height;

        var ctx = canvas.getContext("2d");

        // Create the linear gradient with which to fill the canvas
        var gradient = ctx.createLinearGradient(0, 0, 0, height);
        for(let i=0;i<nmax;i++){
          gradient.addColorStop(i/nmax, getColor(points[i],vmin,vmax));
        }
        // Fill the canvas with the gradient pattern
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);

        return canvas;
    }

    function getColor(v, vmin, vmax){
        var c = 'rgba(' + 255 + ',' + 255 + ',' + 255 + ',' + 0.15 + ')';
        if (v < vmin){
          v = vmin;
        }          
        if (v > vmax){
          v = vmax;
        }
        var dv = vmax - vmin;
        var a = 0.15+0.6*(v - vmin) / dv;

        if (v < (vmin + 0.25 * dv)) {
            var g = Math.floor( 4 * (v - vmin) / dv*255);
            
            c = 'rgba(' + 0 + ',' + g + ',' + 255 + ',' + a + ')'
        } else if (v < (vmin + 0.5 * dv)) {
            var b = 1 + 4 * (vmin + 0.25 * dv - v) / dv;
            b = Math.floor(b*255);
            c = 'rgba(' + 0 + ',' + 255 + ',' + b + ',' + a + ')'
        } else if (v < (vmin + 0.75 * dv)) {
            var r = 4 * (v - vmin - 0.5 * dv) / dv;
            r = Math.floor(r*255);
            c = 'rgba(' + r + ',' + 255 + ',' + 0 + ',' + a + ')'
        } else {
            var g = 1 + 4 * (vmin + 0.75 * dv - v) / dv;
            g = Math.floor(g*255);
            c = 'rgba(' + 255 + ',' + g + ',' + 0 + ',' + a + ')'
        }
        return c;
      }

    $.post('{{ url_for('main.get_ppi_data') }}', { 'task id': task_id, 'content':'list' },
        function(data,status){
        var sel1 = document.getElementById('timeSeries');
        for(let i=0; i<data.result.length;i++){
            sel1.options.add(new Option(data.result[i].timestamp+""));
        };
        $.post('{{ url_for('main.get_ppi_data') }}', { 'task id': task_id, 'content':'timedata', 'time': sel1.options[0].text},
            function(data,status){
            rdata.raw_A = [];
            rdata.raw_B = [];
            rdata.prr_A = [];
            rdata.prr_B = [];
            rdata.ext = [];
            rdata.dep = [];
            resolution = data.result[0].resolution;
            verAng = data.result[0].verAngle;
            horAngStart = data.result[0].horAngle;
            horAngEnd = data.result[data.result.length-1].horAngle;
            horAngStep = data.result[1].horAngle - data.result[0].horAngle;
            var validI = 0;
            for(let i=0; i<data.result.length;i++){
                if(data.result[i].longitude>0){
                validI = i;
                };
            };
            longitude = data.result[validI].longitude<0?0:data.result[validI].longitude;
            latitude = data.result[validI].latitude<0?0:data.result[validI].latitude;
            altitude = data.result[validI].altitude<0?0:data.result[validI].altitude;
            position = new AMap.LngLat(longitude, latitude)
            for(let i=0; i<data.result.length;i++){
                rdata.prr_A.push(data.result[i].prr_A);
                rdata.prr_B.push(data.result[i].prr_B);
                rdata.raw_A.push(data.result[i].raw_A);
                rdata.raw_B.push(data.result[i].raw_B);
                rdata.ext.push(data.result[i].ext);
                rdata.dep.push(data.result[i].dep);
            };
            drawData = rdata.prr_A;
            createPie(position,drawData,resolution,rangeMax,verAng,horAngStart,horAngEnd,horAngStep,vMin,vMax);
            map.setCenter(position);
        });
    });
      


</script>



{% endblock %}