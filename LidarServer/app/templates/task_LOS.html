{% extends "base.html" %}

{% block app_content %}
<style type="text/css">
.inputNum {
  width: 6em;
  text-align: right;
}
.PRDiv{
  position: relative;
  float:right;
  width:900px;
  z-index: 100;
}
.lineDiv{
  position: relative;
  float:right;
  width:290px;
  margin-left:-50px;
  z-index: 10;
}
.saveLine{
  z-index: 100;
  position: absolute;
  right: 60px;
  top: 42px;
  border-radius: 3px;
  background-color: rgb(255, 255, 255);
}
.savePic{
  z-index: 100;
  position: absolute;
  right: 10px;
  top: 42px;
  border-radius: 3px;
  background-color: rgb(255, 255, 255);
}

</style>

<div>
<select  id="channelA" onchange="SelectChannelA()">
  <option>平行通道距离校正信号</option>
  <option>垂直通道距离校正信号</option>
  <option>消光系数</option>
  <option>退偏比</option>
  <option>污染边界层</option>
  <option>平行通道原始信号</option>
  <option>垂直通道原始信号</option>
</select>
<span>
  &nbsp;&nbsp;&nbsp;&nbsp;从<input type="number" id="zMinA" value="0" class="inputNum" max="30000" min="15" onchange="ChangeChannelARangeMin()">
  至<input type="number" id="zMaxA" value="3000" class="inputNum" max="30000" min="15" onchange="ChangeChannelARangeMax()">&nbsp;&nbsp;&nbsp;&nbsp;
</span>
<span>
  色标最小值<input type="number" id="colorMinA" value="0" class="inputNum" onchange="ChangeChannelAMin()">
  色标最大值<input type="number" id="colorMaxA" value="10000" class="inputNum" onchange="ChangeChannelAMax()">
</span>
</div>
<div>
    <div class = 'lineDiv' id='lineADiv'>  
        <input class="saveLine" type="image" title="保存廓线" src="../static/save.png" onclick="SaveLineA()"/>
    </div>
    <div class = 'PRDiv' id="PRADiv"><!-- Plotly chart will be drawn inside this DIV -->
      <input class="savePic" type="image" title="保存图片" src="../static/save.png" onclick="SaveHeatA()"/>
    </div>
</div>

<div style="clear:both">
<select  id="channelB" onchange="SelectChannelB()">
    <option>垂直通道距离校正信号</option>
    <option>平行通道距离校正信号</option>
    <option>消光系数</option>
    <option>退偏比</option>
    <option>污染边界层</option>
    <option>平行通道原始信号</option>
    <option>垂直通道原始信号</option>
  </select>
  <span>
    &nbsp;&nbsp;&nbsp;&nbsp;从<input type="number" id="zMinB" value="0" class="inputNum" max="30000" min="15" onchange="ChangeChannelBRangeMin()">
    至<input type="number" id="zMaxB" value="3000" class="inputNum" max="30000" min="15" onchange="ChangeChannelBRangeMax()">&nbsp;&nbsp;&nbsp;&nbsp;
  </span>
  <span>
    色标最小值<input type="number" id="colorMinB" value="0" class="inputNum" onchange="ChangeChannelBMin()">
    色标最大值<input type="number" id="colorMaxB" value="10000" class="inputNum" onchange="ChangeChannelBMax()">
  </span>
  <button onclick="SaveHeatB()">保存图片</button>
  <button onclick="SaveLineB()">保存廓线</button>
</div>
  <div>
      <div class = 'lineDiv' id='lineBDiv'>
        <input class="saveLine" type="image" title="保存廓线" src="../static/save.png" onclick="SaveLineB()"/>
      </div>
      <div class = 'PRDiv' id="PRBDiv"><!-- Plotly chart will be drawn inside this DIV -->
        <input class="savePic" type="image" title="保存图片" src="../static/save.png" onclick="SaveHeatB()"/>
      </div>
  </div>

{% endblock %}

{% block app_scripts %}
<script src="../static/plotly-latest.min.js"></script>

<script>
    var task_id = '{{task_id}}';
    var linePRA=[];
    var linePRB=[];
    var timeat=[];
    var height = [];
    var lineA = [];
    var lineB = [];
    var lineExt = [];
    var lineDep = [];
    var linePbl = [];
    var AMin = 0;
    var AMax = 10000;
    var BMin = 0;
    var BMax = 10000;
    var lineIndex = 0;
    var drawDataA={}, drawDataB={};
    var drawNameA = '平行通道距离校正信号',drawNameB='垂直通道距离校正信号'
    var res = 15;
    var layoutA = {
            xaxis: {
              title: '时间',
              showline: true,
              tickmode:'auto',
              range:[],
              showspikes: true,
              spikemode: 'across'
            },
            yaxis: {
              title: '距离(km)',
              showline: true,
              range:[0,3]
            }
          };
    var layoutB = {
            xaxis: {
              title: '时间',
              showline: true,
              tickmode:'auto',
              range:[],
              showspikes: true,
              spikemode: 'across'
            },
            yaxis: {
              title: '距离(km)',
              showline: true,
              range:[0,3]
            }
          };  
    var layoutLineA = {
      xaxis: {
        title: '强度',
        showline: true,
        tickmode:'auto',
        showexponent:"last",
        exponentformat:"power"
      },
      yaxis: {
        showline: true,
        range:[0,3],
        ticks:'outside'
      },
      annotations: [{
      showarrow: false,
      text: "",
      font: {
        color: 'black'
      },
      xref: 'paper',
      yref: 'paper',
      x: 0.5,
      y: 0.5
    }]
    };
    var layoutLineB = {
      xaxis: {
        title: '强度',
        showline: true,
        tickmode:'auto',
        showexponent:"last",
        exponentformat:"power"
      },
      yaxis: {
        showline: true,
        range:[0,3],
        ticks:'outside'
      },
      annotations: [{
      showarrow: false,
      text: "",
      font: {
        color: 'black'
      },
      xref: 'paper',
      yref: 'paper',
      x: 0.5,
      y: 0.5
    }]
    };
    var layoutConfig = {
      displayModeBar: false,
      responsive: true
    };
    var PRA_data ={},PRB_data={},traceA={},traceB={},traceIndex={},tracePblA={},tracePblB={};

    $.post('{{ url_for('main.get_los_data') }}', { 'task id': task_id },
        function(data,status){
        if(status == "success"){
          res = data.result[0].resolution/1000;
          leng = data.result[0].raw_A.length;        
          for(let i = 0;i<leng;i++){
            height.push((i+1)*res);
          };
          for(let i=0; i<data.result.length;i++){
            timeat.push(data.result[i].timestamp);
            lineA.push(data.result[i].raw_A);
            lineB.push( data.result[i].raw_B);
            linePRA.push(data.result[i].prr_A);
            linePRB.push(data.result[i].prr_B);
            lineExt.push(data.result[i].ext);
            lineDep.push(data.result[i].dep);
            linePbl.push(data.result[i].pbl/1000);
          };
          drawDataA = linePRA;
          PRA_data = {
              z: linePRA,
              x: timeat,
              y: height,
              zmin: 0,
              zmax: 10000,
              type: 'heatmap',
              transpose: true,
              colorscale:createColorScale(11),
              colorbar:{
                thickness:15,
                xpad:5,
                showexponent:"last",
                exponentformat:"power"
              }
          };
          drawDataB = linePRB;
          PRB_data = {
              z: linePRB,
              x: timeat,
              y: height,
              zmin:0,
              zmax: 10000,
              type: 'heatmap',
              transpose: true,
              colorscale:createColorScale(11),
              colorbar:{
                thickness:15,
                xpad:5,
                showexponent:"last",
                exponentformat:"power"
              }
          };

          traceA = {
            x: linePRA[0].slice(layoutLineA.yaxis.range[0]/res,layoutLineA.yaxis.range[1]/res),
            y: height,
            mode: 'lines',
            line: {
              color: 'black',
              width: 2
            }
          };

          traceB = {
            x: linePRB[0].slice(layoutLineA.yaxis.range[0]/res,layoutLineA.yaxis.range[1]/res),
            y: height,
            mode: 'lines',
            line: {
              color: 'black',
              width: 2
            }
          };

          tracePblA = {
            x:timeat,
            y:linePbl,
            mode:'markers',
            type:'scatter',
            marker:{color:'black'},
            showlegend:false,
            visible:false
          };
          tracePblB = {
            x:timeat,
            y:linePbl,
            mode:'markers',
            type:'scatter',
            marker:{color:'black'},
            showlegend:false,
            visible:false
          };

          layoutA.xaxis.range = [timeat[0],timeat[timeat.length-1]];
          layoutB.xaxis.range = [timeat[0],timeat[timeat.length-1]];
          layoutLineA.annotations[0].text = timeat[lineIndex];
          layoutLineB.annotations[0].text = timeat[lineIndex];
          Plotly.newPlot('PRADiv', [PRA_data,tracePblA], layoutA,layoutConfig);
          Plotly.newPlot('PRBDiv', [PRB_data,tracePblB], layoutB,layoutConfig);
          Plotly.newPlot('lineADiv',[traceA],layoutLineA,layoutConfig);
          Plotly.newPlot('lineBDiv',[traceB],layoutLineB,layoutConfig);

          plotA.on('plotly_hover',plotHover);
          plotB.on('plotly_hover',plotHover);
        };  
      });
    
    function plotHover(data){
      var pn='';
      for(let i=0;i<data.points.length;i++){
        if(data.points[i].fullData.type==='heatmap'){
          pn = data.points[i].pointNumber;
        }
      }
      lineIndex = pn[1];

      traceA.x = drawDataA[lineIndex].slice(layoutLineA.yaxis.range[0]/res,layoutLineA.yaxis.range[1]/res);
      traceA.y = height.slice(layoutLineA.yaxis.range[0]/res,layoutLineA.yaxis.range[1]/res);

      traceB.x = drawDataB[lineIndex].slice(layoutLineB.yaxis.range[0]/res,layoutLineB.yaxis.range[1]/res);
      traceB.y = height.slice(layoutLineB.yaxis.range[0]/res,layoutLineB.yaxis.range[1]/res);
  
      traceIndex.x=[timeat[lineIndex],timeat[lineIndex]];

      layoutLineA.annotations[0].text = timeat[lineIndex];
      layoutLineB.annotations[0].text = timeat[lineIndex];
      Plotly.react('lineADiv',[traceA],layoutLineA);
      Plotly.react('lineBDiv',[traceB],layoutLineB);
    }

    var plotA = document.getElementById('PRADiv');
    var plotB = document.getElementById('PRBDiv');
    

    function createColorScale(n){
      var colorScale = [];
      for(let i=0;i<n;i++){
        var c = getColor(i/(n-1),0,1,1);
        var rgbStr = 'rgb('+Math.floor(c.r*255)+','+Math.floor(c.g*255)+','+Math.floor(c.b*255)+')';
        colorScale.push([i/(n-1),rgbStr]);
      }
      return colorScale;
    }

    function getColor(v, vmin, vmax, alpha){
        var c = {};
        if (v < vmin){
          v = vmin;
        }          
        if (v > vmax){
          v = vmax;
        }
        var dv = vmax - vmin;
        c.a = alpha-0.1+0.2*(v - vmin) / dv;

        if (v < (vmin + 0.25 * dv)) {
            var g = 4 * (v - vmin) / dv;
            c.r = 0;
            c.g = g;
            c.b = 1;
        } else if (v < (vmin + 0.5 * dv)) {
            var b = 1 + 4 * (vmin + 0.25 * dv - v) / dv;
            c.r = 0;
            c.g = 1;
            c.b = b;
        } else if (v < (vmin + 0.75 * dv)) {
            var r = 4 * (v - vmin - 0.5 * dv) / dv;
            c.r = r;
            c.g = 1;
            c.b = 0;
        } else {
            var g = 1 + 4 * (vmin + 0.75 * dv - v) / dv;
            c.r = 1;
            c.g = g;
            c.b = 0;
        }
        return c;
    }

    function SelectChannelA(){
        var channel = document.getElementById('channelA');
        tracePblA.visible = false;
        drawNameA = channel.options[channel.selectedIndex].text;
        switch(drawNameA){
          case '平行通道距离校正信号':
            drawDataA = linePRA;
            break;
          case '垂直通道距离校正信号':
            drawDataA = linePRB;
            break;
          case '消光系数':
            drawDataA = lineExt;
            break;
          case '退偏比':
            drawDataA = lineDep;
            break;
          case '平行通道原始信号':
            drawDataA = lineA;
            break;
          case '垂直通道原始信号':
            drawDataA = lineB;
            break;
          case '污染边界层':
            tracePblA.visible = true;
            break;
        };
 
        PRA_data.z = drawDataA;
        traceA.x = drawDataA[lineIndex].slice(layoutLineA.yaxis.range[0]/res,layoutLineA.yaxis.range[1]/res);
        
        Plotly.react('PRADiv',[PRA_data,tracePblA],layoutA);
        Plotly.react('lineADiv',[traceA],layoutLineA);
      }

    function ChangeChannelAMax(){
      var colorMax = document.getElementById('colorMaxA');
      AMax = colorMax.value;
      var update = {
        zmax:AMax
      };
      PRA_data.zmax = AMax;
      Plotly.restyle('PRADiv',update);
    }

    function ChangeChannelAMin(){
      var colorMin = document.getElementById('colorMinA');
      AMin = colorMin.value;
      var update = {
        zmin:AMin
      };
      PRA_data.zmin = AMin;
      Plotly.restyle('PRADiv',update);
    }
  
    function ChangeChannelARangeMax(){
      var rangeMax = document.getElementById('zMaxA');
      layoutA.yaxis.range[1] = rangeMax.value/1000;
      layoutLineA.yaxis.range[1] = rangeMax.value/1000;
      var update = {
        'yaxis.range[1]':rangeMax.value/1000
      };
      Plotly.relayout('PRADiv',update);
      traceA.x = drawDataA[lineIndex].slice(layoutLineA.yaxis.range[0]/res,layoutLineA.yaxis.range[1]/res);
      traceA.y = height.slice(layoutLineA.yaxis.range[0]/res,layoutLineA.yaxis.range[1]/res);
      Plotly.react('lineADiv',[traceA],layoutLineA);
    }

    function ChangeChannelARangeMin(){
      var rangeMin = document.getElementById('zMinA');
      layoutA.yaxis.range[0] = rangeMin.value/1000;
      layoutLineA.yaxis.range[0] = rangeMin.value/1000;
      var update = {
        'yaxis.range[0]':rangeMin.value/1000
      };
      Plotly.relayout('PRADiv',update);
      traceA.x = drawDataA[lineIndex].slice(layoutLineA.yaxis.range[0]/res,layoutLineA.yaxis.range[1]/res);
      traceA.y = height.slice(layoutLineA.yaxis.range[0]/res,layoutLineA.yaxis.range[1]/res);
      Plotly.react('lineADiv',[traceA],layoutLineA);
    }

    function SaveHeatA(){
    	Plotly.downloadImage('PRADiv', {format: 'png', width: 1000, height: 500, filename: drawNameA+'从'
    		                 +timeat[0]+'至'+timeat[timeat.length-1]});
    }

    function SaveLineA(){
    	let csvContent = "";
    	csvContent += 'Data Length,'+drawDataA[lineIndex].length+'\r\n';
        csvContent += 'Resolution,'+res*1000+'\r\n';
        csvContent += drawDataA[lineIndex].join(',')+'\r\n';
        var blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
	      if (navigator.msSaveBlob) { // IE 10+
	          navigator.msSaveBlob(blob, drawNameA+timeat[lineIndex]+".csv");
	      } else {
	          var link = document.createElement("a");
	          if (link.download !== undefined) { // feature detection
	              // Browsers that support HTML5 download attribute
	              var url = URL.createObjectURL(blob);
	              link.setAttribute("href", url);
	              link.setAttribute("download", drawNameA+timeat[lineIndex]+".csv");
	              link.style.visibility = 'hidden';
	              document.body.appendChild(link);
	              link.click();
	              document.body.removeChild(link);
	          }
	      }
    }

    function SelectChannelB(){
        var channel = document.getElementById('channelB');
        tracePblB.visible=false;
        drawNameB = channel.options[channel.selectedIndex].text;
        switch(drawNameB){
          case '平行通道距离校正信号':
            drawDataB = linePRA;
            break;
          case '垂直通道距离校正信号':
            drawDataB = linePRB;
            break;
          case '消光系数':
            drawDataB = lineExt;
            break;
          case '退偏比':
            drawDataB = lineDep;
            break;
          case '平行通道原始信号':
            drawDataB = lineA;
            break;
          case '垂直通道原始信号':
            drawDataB = lineB;
            break;
          case '污染边界层':
            tracePblB.visible = true;
        };

        PRB_data.z = drawDataB;
        traceB.x = drawDataB[lineIndex].slice(layoutLineB.yaxis.range[0]/res,layoutLineB.yaxis.range[1]/res);

        Plotly.react('PRBDiv',[PRB_data,tracePblB],layoutB);
        Plotly.react('lineBDiv',[traceB],layoutLineB);
      }

    function ChangeChannelBMax(){
      var colorMax = document.getElementById('colorMaxB');
      BMax = colorMax.value;
      var update = {
        zmax:BMax
      };
      PRB_data.zmax = BMax;
      Plotly.restyle('PRBDiv',update);
    }

    function ChangeChannelBMin(){
      var colorMin = document.getElementById('colorMinB');
      BMin = colorMin.value;
      var update = {
        zmin:BMin
      };
      PRB_data.zmin = BMin;
      Plotly.restyle('PRBDiv',update);
    }
  
    function ChangeChannelBRangeMax(){
      var rangeMax = document.getElementById('zMaxB');
      layoutB.yaxis.range[1] = rangeMax.value/1000;
      layoutLineB.yaxis.range[1] = rangeMax.value/1000;
      var update = {
        'yaxis.range[1]':rangeMax.value/1000
      };
      Plotly.relayout('PRBDiv',update);
      traceB.x = drawDataB[lineIndex].slice(layoutLineB.yaxis.range[0]/res,layoutLineB.yaxis.range[1]/res);
      traceB.y = height.slice(layoutLineB.yaxis.range[0]/res,layoutLineB.yaxis.range[1]/res);
      Plotly.react('lineBDiv',[traceB],layoutLineB);
    }

    function ChangeChannelBRangeMin(){
      var rangeMin = document.getElementById('zMinB');
      layoutB.yaxis.range[0] = rangeMin.value/1000;
      layoutLineB.yaxis.range[0] = rangeMin.value/1000;
      var update = {
        'yaxis.range[0]':rangeMin.value/1000
      };
      Plotly.relayout('PRBDiv',update);
      traceB.x = drawDataB[lineIndex].slice(layoutLineB.yaxis.range[0]/res,layoutLineB.yaxis.range[1]/res);
      traceB.y = height.slice(layoutLineB.yaxis.range[0]/res,layoutLineB.yaxis.range[1]/res);
      Plotly.react('lineBDiv',[traceB],layoutLineB);
    }

    function SaveHeatB(){
    	Plotly.downloadImage('PRBDiv', {format: 'png', width: 1000, height: 500, filename: drawNameB+'从'
    		                 +timeat[0]+'至'+timeat[timeat.length-1]});
    }

    function SaveLineB(){
    	let csvContent = "";
    	csvContent += 'Data Length,'+drawDataB[lineIndex].length+'\r\n';
        csvContent += 'Resolution,'+res*1000+'\r\n';
        csvContent += drawDataB[lineIndex].join(',')+'\r\n';
        var blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
	      if (navigator.msSaveBlob) { // IE 10+
	          navigator.msSaveBlob(blob, drawNameB+timeat[lineIndex]+".csv");
	      } else {
	          var link = document.createElement("a");
	          if (link.download !== undefined) { // feature detection
	              // Browsers that support HTML5 download attribute
	              var url = URL.createObjectURL(blob);
	              link.setAttribute("href", url);
	              link.setAttribute("download", drawNameB+timeat[lineIndex]+".csv");
	              link.style.visibility = 'hidden';
	              document.body.appendChild(link);
	              link.click();
	              document.body.removeChild(link);
	          }
	      }
    }
</script>

{% endblock %}